package service

import (
	"fmt"
	"strings"

	"github.com/plunder-app/kube-vip/pkg/cluster"
	"github.com/plunder-app/kube-vip/pkg/kubevip"
	log "github.com/sirupsen/logrus"
	"github.com/vishvananda/netlink"
)

func (sm *Manager) stopService(uid string) error {
	found := false
	for x := range sm.serviceInstances {
		if sm.serviceInstances[x].service.UID == uid {
			found = true
			sm.serviceInstances[x].cluster.Stop()
		}
	}
	if found == false {
		return fmt.Errorf("Unable to find/stop service [%s]", uid)
	}
	return nil
}

func (sm *Manager) deleteService(uid string) error {
	var updatedInstances []serviceInstance
	found := false
	for x := range sm.serviceInstances {
		// Add the running services to the new array
		if sm.serviceInstances[x].service.UID != uid {
			updatedInstances = append(updatedInstances, sm.serviceInstances[x])
		} else {
			// Flip the found when we match
			found = true
			if sm.serviceInstances[x].dhcp != nil {
				sm.serviceInstances[x].dhcp.dhcpClient.Stop()
				macvlan, err := netlink.LinkByName(sm.serviceInstances[x].dhcp.dhcpInterface)
				if err != nil {
					return fmt.Errorf("Error finding VIP Interface, for building DHCP Link : %v", err)
				}
				netlink.LinkDel(macvlan)
			}
			if sm.serviceInstances[x].vipConfig.EnableBGP {
				cidrVip := fmt.Sprintf("%s/%s", sm.serviceInstances[x].vipConfig.VIP, sm.serviceInstances[x].vipConfig.VIPCIDR)
				err := sm.bgpServer.DelHost(cidrVip)
				return err
			}
		}
	}
	// If we've been through all services and not found the correct one then error
	if found == false {
		return fmt.Errorf("Unable to find/stop service [%s]", uid)
	}

	// Update the service array
	sm.serviceInstances = updatedInstances

	log.Debugf("Removed [%s] from manager, [%d] services remain", uid, len(sm.serviceInstances))

	return nil
}

func (sm *Manager) syncServices(s *plndrServices) error {
	log.Debugf("[STARTING] Service Sync")
	// Iterate through the synchronising services
	for x := range s.Services {
		foundInstance := false
		for y := range sm.serviceInstances {
			if s.Services[x].UID == sm.serviceInstances[y].service.UID {
				// We have found this instance in the manager and we can update it
				foundInstance = true
			}
		}

		// Generate new Virtual IP configuration
		newVip := kubevip.Config{
			VIP:        s.Services[x].Vip,
			Interface:  sm.config.Interface,
			SingleNode: true,
			EnableARP:  sm.config.EnableARP,
			EnableBGP:  sm.config.EnableBGP,
			VIPCIDR:    sm.config.VIPCIDR,
		}

		// This instance wasn't found, we need to add it to the manager
		if foundInstance == false {
			// Create new service
			var newService serviceInstance

			// If this was purposely created with the address 0.0.0.0 then we will create a macvlan on the main interface and try DHCP
			if s.Services[x].Vip == "0.0.0.0" {

				err := sm.createDHCPService(s.Services[x].UID, &newVip, newService, service)
				if err != nil {
					return err
				}

			}
			log.Infof("New VIP [%s] for [%s/%s] ", s.Services[x].Vip, s.Services[x].ServiceName, s.Services[x].UID)

			// Generate Load Balancer config
			newLB := kubevip.LoadBalancer{
				Name:      fmt.Sprintf("%s-load-balancer", s.Services[x].ServiceName),
				Port:      s.Services[x].Port,
				Type:      s.Services[x].Type,
				BindToVip: true,
			}

			// Add Load Balancer Configuration
			newVip.LoadBalancers = append(newVip.LoadBalancers, newLB)

			// Create Add configuration to the new service
			newService.vipConfig = newVip
			newService.service = s.Services[x]

			// TODO - start VIP
			c, err := cluster.InitCluster(&newService.vipConfig, false)
			if err != nil {
				log.Errorf("Failed to add Service [%s] / [%s]", s.Services[x].ServiceName, s.Services[x].UID)
				return err
			}
			err = c.StartLoadBalancerService(&newService.vipConfig, sm.bgpServer)
			if err != nil {
				log.Errorf("Failed to add Service [%s] / [%s]", s.Services[x].ServiceName, s.Services[x].UID)
				return err
			}

			sm.upnpMap(s.Services[x])

			newService.cluster = *c

			// Begin watching this service
			go sm.newWatcher(&newService)

			// Add new service to manager configuration
			sm.serviceInstances = append(sm.serviceInstances, newService)
		}
	}
	log.Debugf("[COMPLETE] Service Sync")

	return nil
}

func (sm *Manager) upnpMap(s service) {
	// If upnp is enabled then update the gateway/router with the address
	// TODO - work out if we need to mapping.Reclaim()
	if sm.upnp != nil {

		log.Infof("[UPNP] Adding map to [%s:%d - %s]", s.Vip, s.Port, s.ServiceName)
		if err := sm.upnp.AddPortMapping(s.Port, s.Port, 0, s.Vip, strings.ToUpper(s.Type), s.ServiceName); err == nil {
			log.Infof("Service should be accessible externally on port [%d]", s.Port)
		} else {
			sm.upnp.Reclaim()
			log.Errorf("Unable to map port to gateway [%s]", err.Error())
		}
	}
}
